-- Advanced SQL Queries for Sales Dashboard Analysis
-- Assumed schema (adjust names/types to match your DB):
-- Database: sales_dashboard
-- Tables:
--   products(product_id INT PRIMARY KEY, product_name TEXT, category TEXT, price DECIMAL)
--   customers(customer_id INT PRIMARY KEY, customer_name TEXT, region TEXT, signup_date DATE)
--   sales(sale_id INT PRIMARY KEY, product_id INT, customer_id INT, quantity INT, sale_date DATE, total_amount DECIMAL)
--   (optionally) returns(return_id, sale_id, return_date, amount)

-------------------------------------------------------------------------------
-- 0. Useful setup: create indexes for performance (run once)
-------------------------------------------------------------------------------
CREATE INDEX IF NOT EXISTS idx_sales_date ON sales(sale_date);
CREATE INDEX IF NOT EXISTS idx_sales_product ON sales(product_id);
CREATE INDEX IF NOT EXISTS idx_sales_customer ON sales(customer_id);

-------------------------------------------------------------------------------
-- 1. Monthly sales trend (Month / Year) - totals and % change month-over-month
-------------------------------------------------------------------------------
WITH monthly AS (
  SELECT
    DATE_TRUNC('month', sale_date) AS month,
    SUM(total_amount) AS total_sales
  FROM sales
  GROUP BY 1
)
SELECT
  month,
  total_sales,
  LAG(total_sales) OVER (ORDER BY month) AS prev_month_sales,
  ROUND( (total_sales - LAG(total_sales) OVER (ORDER BY month)) / NULLIF(LAG(total_sales) OVER (ORDER BY month),0) * 100, 2) AS pct_change
FROM monthly
ORDER BY month;

-------------------------------------------------------------------------------
-- 2. Year-over-Year (YoY) sales by month
-------------------------------------------------------------------------------
SELECT
  EXTRACT(YEAR FROM sale_date)::INT AS year,
  TO_CHAR(sale_date, 'Mon') AS month_name,
  SUM(total_amount) AS monthly_sales
FROM sales
GROUP BY 1,2, DATE_TRUNC('month', sale_date)
ORDER BY year, DATE_TRUNC('month', sale_date);

-------------------------------------------------------------------------------
-- 3. Top 10 products by revenue and unit volume
-------------------------------------------------------------------------------
SELECT
  p.product_id,
  p.product_name,
  p.category,
  SUM(s.total_amount) AS revenue,
  SUM(s.quantity) AS units_sold
FROM sales s
JOIN products p ON s.product_id = p.product_id
GROUP BY p.product_id, p.product_name, p.category
ORDER BY revenue DESC
LIMIT 10;

-------------------------------------------------------------------------------
-- 4. Top N products per region (using ROW_NUMBER)
-------------------------------------------------------------------------------
SELECT product_id, product_name, category, region, revenue
FROM (
  SELECT
    p.product_id,
    p.product_name,
    p.category,
    c.region,
    SUM(s.total_amount) AS revenue,
    ROW_NUMBER() OVER (PARTITION BY c.region ORDER BY SUM(s.total_amount) DESC) AS rn
  FROM sales s
  JOIN products p ON s.product_id = p.product_id
  JOIN customers c ON s.customer_id = c.customer_id
  GROUP BY c.region, p.product_id, p.product_name, p.category
) t
WHERE rn <= 5
ORDER BY region, revenue DESC;

-------------------------------------------------------------------------------
-- 5. Top customers by lifetime value (LTV) and cohort (signup year)
-------------------------------------------------------------------------------
SELECT
  c.customer_id,
  c.customer_name,
  EXTRACT(YEAR FROM c.signup_date)::INT AS cohort_year,
  SUM(s.total_amount) AS lifetime_value,
  COUNT(DISTINCT s.sale_id) AS purchases
FROM customers c
LEFT JOIN sales s ON c.customer_id = s.customer_id
GROUP BY c.customer_id, c.customer_name, cohort_year
ORDER BY lifetime_value DESC
LIMIT 20;

-------------------------------------------------------------------------------
-- 6. Recency-Frequency-Monetary (RFM) segmentation
-------------------------------------------------------------------------------
WITH rfm AS (
  SELECT
    c.customer_id,
    MAX(s.sale_date) AS last_purchase,
    COUNT(s.sale_id) AS frequency,
    COALESCE(SUM(s.total_amount),0) AS monetary
  FROM customers c
  LEFT JOIN sales s ON c.customer_id = s.customer_id
  GROUP BY c.customer_id
),
scores AS (
  SELECT
    customer_id,
    -- adjust quantile cutoffs as needed; simple example using NTILE
    NTILE(4) OVER (ORDER BY last_purchase DESC) AS recency_score,
    NTILE(4) OVER (ORDER BY frequency ASC) AS frequency_score,
    NTILE(4) OVER (ORDER BY monetary ASC) AS monetary_score,
    monetary
  FROM rfm
)
SELECT *, (recency_score*100 + frequency_score*10 + monetary_score) AS rfm_weight
FROM scores
ORDER BY rfm_weight DESC
LIMIT 50;

-------------------------------------------------------------------------------
-- 7. Customer retention cohort analysis (monthly cohorts)
-- Shows count of customers from cohort month who returned in subsequent months
-------------------------------------------------------------------------------
WITH cohorts AS (
  SELECT
    customer_id,
    DATE_TRUNC('month', MIN(sale_date)) AS cohort_month
  FROM sales
  GROUP BY customer_id
),
activity AS (
  SELECT
    c.cohort_month,
    DATE_TRUNC('month', s.sale_date) AS activity_month,
    COUNT(DISTINCT s.customer_id) AS customers_active
  FROM sales s
  JOIN cohorts c ON s.customer_id = c.customer_id
  GROUP BY c.cohort_month, DATE_TRUNC('month', s.sale_date)
)
SELECT
  cohort_month,
  activity_month,
  customers_active,
  ROUND( customers_active::NUMERIC / NULLIF( (SELECT COUNT(DISTINCT customer_id) FROM sales WHERE DATE_TRUNC('month', sale_date)=cohort_month), 0) * 100, 2) AS retention_pct
FROM activity
ORDER BY cohort_month, activity_month;

-------------------------------------------------------------------------------
-- 8. Average order value (AOV) and median order value
-------------------------------------------------------------------------------
SELECT
  AVG(total_amount) AS avg_order_value,
  PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY total_amount) AS median_order_value
FROM sales;

-------------------------------------------------------------------------------
-- 9. Sales by weekday and hour (day/time heatmap)
-- If you store a sale_time column, use that; else analyze by date only for weekday
-------------------------------------------------------------------------------
SELECT
  TO_CHAR(sale_date, 'Day') AS weekday,
  COUNT(*) AS orders,
  SUM(total_amount) AS revenue
FROM sales
GROUP BY 1
ORDER BY CASE
  WHEN TO_CHAR(sale_date, 'D')::INT = 1 THEN 1 -- ordering varies by DB locale; adjust as needed
  ELSE 2 END, weekday;

-------------------------------------------------------------------------------
-- 10. Moving average of daily sales (7-day window)
-------------------------------------------------------------------------------
WITH daily AS (
  SELECT DATE_TRUNC('day', sale_date) AS day, SUM(total_amount) AS daily_sales
  FROM sales
  GROUP BY 1
)
SELECT
  day,
  daily_sales,
  ROUND(AVG(daily_sales) OVER (ORDER BY day ROWS BETWEEN 6 PRECEDING AND CURRENT ROW),2) AS ma_7d
FROM daily
ORDER BY day;

-------------------------------------------------------------------------------
-- 11. Contribution to revenue by category (percentage)
-------------------------------------------------------------------------------
SELECT
  p.category,
  SUM(s.total_amount) AS category_sales,
  ROUND( SUM(s.total_amount) / NULLIF( (SELECT SUM(total_amount) FROM sales),0) * 100, 2) AS pct_of_total
FROM sales s
JOIN products p ON s.product_id = p.product_id
GROUP BY p.category
ORDER BY category_sales DESC;

-------------------------------------------------------------------------------
-- 12. Identify sales anomalies (z-score) per product using window functions
-------------------------------------------------------------------------------
WITH prod_stats AS (
  SELECT
    product_id,
    AVG(total_amount) AS mean_sales,
    STDDEV(total_amount) AS sd_sales
  FROM sales
  GROUP BY product_id
)
SELECT s.*, ROUND( (s.total_amount - ps.mean_sales) / NULLIF(ps.sd_sales,0), 2) AS z_score
FROM sales s
JOIN prod_stats ps ON s.product_id = ps.product_id
WHERE ABS( (s.total_amount - ps.mean_sales) / NULLIF(ps.sd_sales,1) ) > 2.5
ORDER BY product_id, z_score DESC;

-------------------------------------------------------------------------------
-- 13. Sales growth rate per product (quarterly)
-------------------------------------------------------------------------------
WITH quarterly AS (
  SELECT
    product_id,
    DATE_TRUNC('quarter', sale_date) AS quarter,
    SUM(total_amount) AS q_sales
  FROM sales
  GROUP BY product_id, DATE_TRUNC('quarter', sale_date)
)
SELECT
  product_id,
  quarter,
  q_sales,
  LAG(q_sales) OVER (PARTITION BY product_id ORDER BY quarter) AS prev_q_sales,
  ROUND( (q_sales - LAG(q_sales) OVER (PARTITION BY product_id ORDER BY quarter)) / NULLIF(LAG(q_sales) OVER (PARTITION BY product_id ORDER BY quarter),0) * 100, 2) AS pct_change_qoq
FROM quarterly
ORDER BY product_id, quarter;

-------------------------------------------------------------------------------
-- 14. Basket analysis (frequent item pairs) - approximate using self-join on order/session
-- Assumes sale_id groups items of same order (if one line per product per order)
-------------------------------------------------------------------------------
SELECT
  a.product_id AS product_a,
  b.product_id AS product_b,
  p1.product_name AS name_a,
  p2.product_name AS name_b,
  COUNT(*) AS times_bought_together
FROM sales a
JOIN sales b ON a.sale_id = b.sale_id AND a.product_id < b.product_id
JOIN products p1 ON a.product_id = p1.product_id
JOIN products p2 ON b.product_id = p2.product_id
GROUP BY a.product_id, b.product_id, p1.product_name, p2.product_name
ORDER BY times_bought_together DESC
LIMIT 50;

-------------------------------------------------------------------------------
-- 15. Top returning customers (repeat purchase behavior)
-------------------------------------------------------------------------------
WITH purchases AS (
  SELECT customer_id, COUNT(*) AS orders, MIN(sale_date) AS first_order, MAX(sale_date) AS last_order
  FROM sales
  GROUP BY customer_id
)
SELECT
  p.customer_id,
  c.customer_name,
  p.orders,
  p.first_order,
  p.last_order,
  ROUND( (p.orders::NUMERIC / NULLIF(DATE_PART('day', p.last_order - p.first_order),0)), 2) AS purchases_per_day
FROM purchases p
JOIN customers c ON p.customer_id = c.customer_id
WHERE p.orders > 1
ORDER BY p.orders DESC
LIMIT 50;

-------------------------------------------------------------------------------
-- 16. Stock / replenishment hint: average lead time between sales for product (proxy)
-------------------------------------------------------------------------------
SELECT
  product_id,
  AVG(days_between) AS avg_days_between_sales
FROM (
  SELECT
    product_id,
    sale_date,
    LAG(sale_date) OVER (PARTITION BY product_id ORDER BY sale_date) AS prev_date,
    EXTRACT(DAY FROM (sale_date - LAG(sale_date) OVER (PARTITION BY product_id ORDER BY sale_date))) AS days_between
  FROM sales
) t
WHERE days_between IS NOT NULL
GROUP BY product_id;

-------------------------------------------------------------------------------
-- 17. Windowed percent contribution per product within region (share of regional revenue)
-------------------------------------------------------------------------------
SELECT *
FROM (
  SELECT
    c.region,
    p.product_id,
    p.product_name,
    SUM(s.total_amount) AS revenue,
    SUM(SUM(s.total_amount)) OVER (PARTITION BY c.region) AS region_total,
    ROUND( SUM(s.total_amount) / NULLIF(SUM(SUM(s.total_amount)) OVER (PARTITION BY c.region),0) * 100, 2) AS pct_of_region
  FROM sales s
  JOIN products p ON s.product_id = p.product_id
  JOIN customers c ON s.customer_id = c.customer_id
  GROUP BY c.region, p.product_id, p.product_name
) x
ORDER BY region, revenue DESC;

-------------------------------------------------------------------------------
-- 18. Profitability proxy: assuming products.price is cost basis or add a 'cost' column.
-- If products.price is list price, and sales.total_amount is actual, compute margin.
-------------------------------------------------------------------------------
-- Example: add a cost column first (one-time update) or join with cost table
-- SELECT p.product_id, p.product_name, SUM(s.total_amount) AS revenue, SUM(s.quantity * p.cost) AS cost, (revenue - cost) AS gross_profit

-------------------------------------------------------------------------------
-- 19. Advanced: forecasting using SQL (simple linear trend) using regression formula
-- Note: This is approximate and DB-specific; PostgreSQL supports REGR_SLOPE/REGR_INTERCEPT
-------------------------------------------------------------------------------
-- Monthly trend with linear regression prediction for next 3 months (Postgres)
WITH monthly AS (
  SELECT
    EXTRACT(YEAR FROM sale_date)::INT AS yr,
    EXTRACT(MONTH FROM sale_date)::INT AS mon,
    (EXTRACT(YEAR FROM sale_date)::INT * 12 + EXTRACT(MONTH FROM sale_date)::INT) AS month_index,
    SUM(total_amount) AS total_sales
  FROM sales
  GROUP BY 1,2
)
SELECT
  REGR_SLOPE(total_sales, month_index) AS slope,
  REGR_INTERCEPT(total_sales, month_index) AS intercept
FROM monthly;

-- Use slope/intercept to project future month_index -> predicted_sales = intercept + slope * month_index

-------------------------------------------------------------------------------
-- 20. SQL to create materialized view for dashboard (fast refresh)
-------------------------------------------------------------------------------
CREATE MATERIALIZED VIEW IF NOT EXISTS mv_monthly_sales AS
SELECT DATE_TRUNC('month', sale_date) AS month, SUM(total_amount) AS total_sales, COUNT(*) AS orders
FROM sales
GROUP BY 1
ORDER BY 1;

-- Then refresh with:
-- REFRESH MATERIALIZED VIEW mv_monthly_sales;

-------------------------------------------------------------------------------
-- 21. KPI snapshot: single-row summary (today / last 7 days / last 30 days)
-------------------------------------------------------------------------------
SELECT
  (SELECT SUM(total_amount) FROM sales WHERE sale_date = CURRENT_DATE) AS sales_today,
  (SELECT SUM(total_amount) FROM sales WHERE sale_date >= CURRENT_DATE - INTERVAL '7 day') AS sales_last_7d,
  (SELECT SUM(total_amount) FROM sales WHERE sale_date >= CURRENT_DATE - INTERVAL '30 day') AS sales_last_30d,
  (SELECT COUNT(DISTINCT customer_id) FROM sales WHERE sale_date >= CURRENT_DATE - INTERVAL '30 day') AS unique_customers_30d;

-------------------------------------------------------------------------------
-- 22. Dynamic Top-K: get top product per region using DISTINCT ON (Postgres) or windowing
-------------------------------------------------------------------------------
-- Postgres DISTINCT ON version
SELECT DISTINCT ON (region) region, product_name, revenue
FROM (
  SELECT c.region, p.product_name, SUM(s.total_amount) AS revenue
  FROM sales s
  JOIN products p ON s.product_id = p.product_id
  JOIN customers c ON s.customer_id = c.customer_id
  GROUP BY c.region, p.product_name
  ORDER BY c.region, revenue DESC
) t
ORDER BY region, revenue DESC;

-------------------------------------------------------------------------------
-- 23. Detect stagnating products: products with decreasing revenue for last N months
-------------------------------------------------------------------------------
WITH monthly_prod AS (
  SELECT product_id, DATE_TRUNC('month', sale_date) AS month, SUM(total_amount) AS m_sales
  FROM sales
  GROUP BY product_id, DATE_TRUNC('month', sale_date)
),
trend AS (
  SELECT
    product_id,
    ARRAY_AGG(m_sales ORDER BY month DESC) AS recent_sales -- latest first
  FROM monthly_prod
  GROUP BY product_id
)
SELECT product_id
FROM trend
WHERE recent_sales[1] < recent_sales[2] AND recent_sales[2] < recent_sales[3]; -- last 3 months strictly decreasing

-------------------------------------------------------------------------------
-- 24. Cross-sell opportunity: customers who bought product A but not product B
-- Example: find customers who bought 'Laptop' but never bought 'Laptop Bag'
-------------------------------------------------------------------------------
SELECT DISTINCT s.customer_id
FROM sales s
JOIN products p ON s.product_id = p.product_id
WHERE p.product_name = 'Laptop'
AND s.customer_id NOT IN (
  SELECT customer_id FROM sales s2 JOIN products p2 ON s2.product_id = p2.product_id WHERE p2.product_name = 'Laptop Bag'
);

-------------------------------------------------------------------------------
-- 25. Sales conversion funnel approximation: visits -> carts -> purchases
-- (Requires additional event tables; placeholder example)
-------------------------------------------------------------------------------
-- If you have events(user_id, event_type, event_time), you can compute funnel conversion rates.

-------------------------------------------------------------------------------
-- 26. Export-ready aggregated CSV (example): top 10 products with monthly sales pivot
-------------------------------------------------------------------------------
-- Postgres crosstab extension or use group by with conditional aggregation:
SELECT
  p.product_name,
  SUM(CASE WHEN DATE_TRUNC('month', sale_date) = DATE_TRUNC('month', CURRENT_DATE - INTERVAL '2 month') THEN total_amount ELSE 0 END) AS m_minus_2,
  SUM(CASE WHEN DATE_TRUNC('month', sale_date) = DATE_TRUNC('month', CURRENT_DATE - INTERVAL '1 month') THEN total_amount ELSE 0 END) AS m_minus_1,
  SUM(CASE WHEN DATE_TRUNC('month', sale_date) = DATE_TRUNC('month', CURRENT_DATE) THEN total_amount ELSE 0 END) AS m_current
FROM sales s
JOIN products p ON s.product_id = p.product_id
GROUP BY p.product_name
ORDER BY m_current DESC
LIMIT 50;

-------------------------------------------------------------------------------
-- 27. Data quality checks: missing or suspicious data
-------------------------------------------------------------------------------
-- Orders with zero or negative sales
SELECT * FROM sales WHERE total_amount <= 0;

-- Orders referencing missing product
SELECT s.* FROM sales s LEFT JOIN products p ON s.product_id = p.product_id WHERE p.product_id IS NULL;

-------------------------------------------------------------------------------
-- 28. Audit trail: last N orders with product & customer details
-------------------------------------------------------------------------------
SELECT s.sale_id, s.sale_date, c.customer_name, p.product_name, s.quantity, s.total_amount
FROM sales s
JOIN customers c ON s.customer_id = c.customer_id
JOIN products p ON s.product_id = p.product_id
ORDER BY s.sale_date DESC
LIMIT 200;

-------------------------------------------------------------------------------
-- 29. Cohort LTV over time: average revenue per customer by cohort month after X months
-------------------------------------------------------------------------------
WITH cohort AS (
  SELECT customer_id, DATE_TRUNC('month', MIN(sale_date)) AS cohort_month
  FROM sales
  GROUP BY customer_id
),
events AS (
  SELECT
    c.cohort_month,
    DATE_TRUNC('month', s.sale_date) AS month,
    SUM(s.total_amount) AS revenue,
    COUNT(DISTINCT s.customer_id) AS customers_active
  FROM sales s
  JOIN cohort c ON s.customer_id = c.customer_id
  GROUP BY c.cohort_month, DATE_TRUNC('month', s.sale_date)
)
SELECT
  cohort_month,
  month,
  revenue / NULLIF(customers_active,0) AS avg_revenue_per_active_customer
FROM events
ORDER BY cohort_month, month;

-------------------------------------------------------------------------------
-- 30. Scheduled job example: store daily summary into a table for fast dashboard queries
-------------------------------------------------------------------------------
-- CREATE TABLE daily_summary AS SELECT DATE_TRUNC('day', sale_date) AS day, SUM(total_amount) AS sales, COUNT(*) AS orders FROM sales GROUP BY day;
-- Then use cron / DB scheduler to refresh daily_summary each night.

-------------------------------------------------------------------------------
-- End of advanced queries
-------------------------------------------------------------------------------
